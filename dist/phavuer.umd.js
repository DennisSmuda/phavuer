(function(c,i){typeof exports=="object"&&typeof module<"u"?i(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],i):(c=typeof globalThis<"u"?globalThis:c||self,i(c.Phavuer={},c.Vue))})(this,function(c,i){"use strict";const C=[{attr:"onPointerdown",emit:"pointerdown",eventIndex:3},{attr:"onPointermove",emit:"pointermove",eventIndex:3},{attr:"onPointerup",emit:"pointerup",eventIndex:3},{attr:"onPointerout",emit:"pointerout",eventIndex:1},{attr:"onPointerover",emit:"pointerover",eventIndex:3},{attr:"onWheel",emit:"wheel",eventIndex:4},{attr:"onDragstart",emit:"dragstart",drag:!0},{attr:"onDrag",emit:"drag",drag:!0},{attr:"onDragend",emit:"dragend",drag:!0},{attr:"onDragenter",emit:"dragenter",drag:!0},{attr:"onDragover",emit:"dragover",drag:!0},{attr:"onDragleave",emit:"dragleave",drag:!0},{attr:"onDrop",emit:"drop",drag:!0}],N=e=>{e.updateDisplayOrigin&&e.updateDisplayOrigin(),e.input?e.input.hitArea.setSize(e.width,e.height):e._events&&C.some(t=>t.emit in e._events)&&e.setInteractive()},Y=(e,t,r)=>{let n=e[t];return Object.defineProperty(e,t,{get(){return n},set(o){n!==o&&r(`update:${t}`,o)}}),o=>n=o},k=["tween","tweens","timeline","style"],X=["x","y","tweens","tween","timeline"],A={active:e=>t=>e.setActive(t),visible:e=>t=>e.setVisible(t),x:(e,t)=>t?Y(e,"x",t):r=>e.x=r,y:(e,t)=>t?Y(e,"y",t):r=>e.y=r,x1:e=>t=>e.geom.x1=t,y1:e=>t=>e.geom.y1=t,x2:e=>t=>e.geom.x2=t,y2:e=>t=>e.geom.y2=t,x3:e=>t=>e.geom.x3=t,y3:e=>t=>e.geom.y3=t,points:e=>t=>e.setTo(t),rotation:e=>t=>e.setRotation(t),origin:e=>t=>e.setOrigin(t,t),originX:e=>t=>e.setOrigin(t,e.originY),originY:e=>t=>e.setOrigin(e.originX,t),scale:e=>t=>e.setScale(t,t),scaleX:e=>t=>e.setScale(t,e.scaleY),scaleY:e=>t=>e.setScale(e.scaleX,t),width:e=>t=>{e.setSize(t,e.height),N(e)},height:e=>t=>{e.setSize(e.width,t),N(e)},leftWidth:e=>t=>e.setSlices(e.width,e.height,t,e.rightWidth,e.topHeight,e.bottomHeight),rightWidth:e=>t=>e.setSlices(e.width,e.height,e.leftWidth,t,e.topHeight,e.bottomHeight),topHeight:e=>t=>e.setSlices(e.width,e.height,e.leftWidth,e.rightWidth,t,e.bottomHeight),bottomHeight:e=>t=>e.setSlices(e.width,e.height,e.leftWidth,e.rightWidth,e.topHeight,t),radius:e=>t=>e.setRadius(t),displayWidth:e=>t=>e.setDisplaySize(t,e.displayHeight),displayHeight:e=>t=>e.setDisplaySize(e.displayWidth,t),displayOriginX:e=>t=>e.setDisplayOrigin(t,e.displayOriginY),displayOriginY:e=>t=>e.setDisplayOrigin(e.displayOriginX,t),dropZone:e=>t=>{t&&(e.input||e.setInteractive(),e.input.dropZone=t)},flipX:e=>t=>e.setFlipX(t),flipY:e=>t=>e.setFlipY(t),depth:e=>t=>{if(e.setDepth(t),e.parentContainer){const r=e.parentContainer.list.findIndex(n=>n.depth>(e.depth??0));r===-1?e.parentContainer.bringToTop(e):e.parentContainer.moveTo(e,Math.max(r-1,0))}},alpha:e=>t=>e.setAlpha(t),blendMode:e=>t=>e.setBlendMode(t),pipeline:e=>t=>e.setPipeline(t),intensity:e=>t=>e.setIntensity(t),tint:e=>t=>e.setTint(t),text:e=>t=>e.setText(t),texture:e=>t=>e.setTexture(t,e.frame&&e.frame.name),frame:e=>t=>e.setFrame(t),color:e=>t=>e.setColor(t),fillColor:e=>t=>e.setFillStyle(t,e.fillAlpha),fillAlpha:e=>t=>e.setFillStyle(e.fillColor,t),lineWidth:e=>(t,r)=>{e.setLineWidth?e.setLineWidth(t,r):e.setStrokeStyle(...t?[t,e.strokeColor,e.strokeAlpha]:[])},strokeColor:e=>t=>e.setStrokeStyle(e.lineWidth,t,e.strokeAlpha),strokeAlpha:e=>t=>e.setStrokeStyle(e.lineWidth,e.strokeColor,t),style:e=>t=>e.setStyle(t),lineSpacing:e=>t=>e.setLineSpacing(t),padding:e=>t=>e.setPadding(t),collision:e=>t=>e.setCollision(t),collisionByProperty:e=>t=>e.setCollisionByProperty(t),play:e=>t=>t?e.play(t):e.stop(),scrollFactor:e=>t=>e.setScrollFactor(t),scrollFactorX:e=>t=>e.setScrollFactor(t,e.scrollFactorY),scrollFactorY:e=>t=>e.setScrollFactor(e.scrollFactorX,t),cullPadding:e=>t=>e.setCullPadding(t,t),cullPaddingX:e=>t=>e.setCullPadding(t,e.cullPaddingY),cullPaddingY:e=>t=>e.setCullPadding(e.cullPaddingX,t),enable:e=>t=>e.enable=t,immovable:e=>t=>e.setImmovable(t),moves:e=>t=>e.moves=t,bounceX:e=>t=>e.setBounceX(t),bounceY:e=>t=>e.setBounceY(t),drag:e=>t=>e.setDrag(t),dragX:e=>t=>e.setDragX(t),dragY:e=>t=>e.setDragY(t),gravityX:e=>t=>e.setGravityX(t),gravityY:e=>t=>e.setGravityY(t),frictionX:e=>t=>e.setFrictionX(t),frictionY:e=>t=>e.setFrictionY(t),velocityX:e=>t=>e.setVelocityX(t),velocityY:e=>t=>e.setVelocityY(t),maxVelocityX:e=>t=>e.setMaxVelocityX(t),maxVelocityY:e=>t=>e.setMaxVelocityY(t),accelerationX:e=>t=>e.setAccelerationX(t),accelerationY:e=>t=>e.setAccelerationY(t),offsetX:e=>t=>e.setOffset(t,e.offset.y),offsetY:e=>t=>e.setOffset(e.offset.x,t),collideWorldBounds:e=>t=>e.collideWorldBounds=t,tween:(e,t)=>P(r=>{const n=e.scene.add.tween(Object.assign({targets:e},r));return t&&n.on("complete",()=>t("update:tween",void 0)),n}),tweens:(e,t)=>P(r=>{const n=r.findIndex(s=>s.repeat===-1),o=r.slice(0,n===-1?void 0:n+1),l=e.scene.add.timeline(o.map((s,h)=>({at:o.slice(0,h).reduce((b,$)=>{const S=$.duration??1e3,w=$.yoyo??!1,d=($.repeat??0)+1;return b+S*(w?2:1)*d},0),tween:Object.assign({targets:e},s)}))).play();return t&&l.on("complete",()=>t("update:tweens",void 0)),l}),timeline:(e,t)=>P(r=>{const n=e.scene.add.timeline(r.map(o=>{const l=Object.assign({},o);return l.tween&&(l.tween=Object.assign({targets:e},l.tween)),l})).play();return t&&n.on("complete",()=>t("update:timeline",void 0)),n})},P=e=>{let t;return r=>{t&&t.stop(),t=r?e(r):void 0}},T={version:"0.17.1"},u=(e,t)=>{const r=e.__vccOpts||e;for(const[n,o]of t)r[n]=o;return r},B=i.defineComponent({emits:["create","ready"],props:{config:{type:Object}},setup(e,t){e.config?.banner!==!1&&console.log(`%c %cPhavuer v${T.version}%c https://github.com/laineus/phavuer`,"background-color: #42b883; padding: 2px 0;","background-color: #213547; padding: 2px 8px; color: white; font-weight: bold;","");const r=i.ref(!1),n=i.ref(!1),o=document.createElement("div"),l=new Phaser.Game(Object.assign({parent:o},e.config));return i.provide(a.Game,l),i.provide(a.Scene,void 0),i.provide(a.Container,void 0),i.provide(a.RenderTextureRenderList,void 0),l.events.addListener("ready",()=>{n.value=!0,t.emit("ready",l)}),t.emit("create",l),i.onMounted(()=>{const s=o.firstChild;s&&(r.value.appendChild(s),l.scale.getParent({...l.config,parent:r.value}),l.scale.refresh())}),{canvasRoot:r,show:n}}}),F={"data-phavuer-game":""},E={"data-phavuer-canvas":"",ref:"canvasRoot"};function I(e,t,r,n,o,l){return i.openBlock(),i.createElementBlock("div",F,[i.createElementVNode("div",E,null,512),e.show?i.renderSlot(e.$slots,"default",{key:0}):i.createCommentVNode("",!0)])}const v=u(B,[["render",I]]),L=i.defineComponent({emits:["init","create","update","preload"],props:{name:{type:String,required:!0},autoStart:{type:Boolean,default:!0}},setup(e,t){const r=i.ref(!1),n=[],o=[],l=class extends Phaser.Scene{init(p){t.emit("init",this,p)}create(p){r.value=!0,t.emit("create",this,p)}update(p,b){n.forEach($=>$(p,b)),t.emit("update",this,p,b),o.forEach($=>$(p,b))}preload(){t.emit("preload",this)}},h=i.inject(a.Game).scene.add(e.name,l,e.autoStart);return h.events.on("shutdown",()=>r.value=!1),i.provide(a.Scene,h),i.provide(a.PreUpdateEvents,n),i.provide(a.PostUpdateEvents,o),{scene:h,show:r}}});function D(e,t,r,n,o,l){return e.show?i.renderSlot(e.$slots,"default",{key:0}):i.createCommentVNode("",!0)}const U=u(L,[["render",D]]),M=Object.entries({active:{type:Boolean},visible:{type:Boolean},x:{type:Number},y:{type:Number},x1:{type:Number},y1:{type:Number},x2:{type:Number},y2:{type:Number},x3:{type:Number},y3:{type:Number},points:{type:Array},rotation:{type:Number},origin:{type:Number},originX:{type:Number},originY:{type:Number},scale:{type:Number},scaleX:{type:Number},scaleY:{type:Number},width:{type:Number},height:{type:Number},leftWidth:{type:Number},rightWidth:{type:Number},topHeight:{type:Number},bottomHeight:{type:Number},radius:{type:Number},displayWidth:{type:Number},displayHeight:{type:Number},displayOriginX:{type:Number},displayOriginY:{type:Number},dropZone:{type:Boolean},flipX:{type:Boolean},flipY:{type:Boolean},depth:{type:Number},alpha:{type:Number},blendMode:{type:[Number,String]},pipeline:{type:[String,Object]},intensity:{type:Number},tint:{type:Number},text:{type:[String,Number]},texture:{type:String},frame:{type:[Number,String]},color:{type:String},fillColor:{type:Number},fillAlpha:{type:Number},lineWidth:{type:Number},strokeColor:{type:Number},strokeAlpha:{type:Number},style:{type:Object},lineSpacing:{type:Number},padding:{type:[Number,Object]},collision:{type:[Number,Array]},collisionByProperty:{type:Object},play:{type:[String,Object]},scrollFactor:{type:Number},scrollFactorX:{type:Number},scrollFactorY:{type:Number},enable:{type:Boolean},immovable:{type:Boolean},moves:{type:Boolean},bounceX:{type:Number},bounceY:{type:Number},drag:{type:Number},dragX:{type:Number},dragY:{type:Number},gravityX:{type:Number},gravityY:{type:Number},frictionX:{type:Number},frictionY:{type:Number},velocityX:{type:Number},velocityY:{type:Number},maxVelocityX:{type:Number},maxVelocityY:{type:Number},accelerationX:{type:Number},accelerationY:{type:Number},offsetX:{type:Number},offsetY:{type:Number},collideWorldBounds:{type:Boolean},tween:{type:Object},tweens:{type:Array},timeline:{type:Object}}),f=(...e)=>{const t=new Set(e);return Object.fromEntries(M.filter(([r])=>t.has(r)))},g=f("tween","tweens","timeline","active","visible","x","y","rotation","origin","originX","originY","displayOriginX","displayOriginY","scale","scaleX","scaleY","displayWidth","displayHeight","scrollFactor","scrollFactorX","scrollFactorY","dropZone","depth","alpha","blendMode","pipeline"),j=C.map(e=>e.emit),H=X.map(e=>`update:${e}`),y=["create",...j,...H],V=i.defineComponent({emits:[...y],props:Object.fromEntries(Object.entries(g).filter(([e])=>!["origin","originX","originY","displayOriginX","displayOriginY"].includes(e))),setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Container(r,e.x||0,e.y||0);return m(n,e,t),i.provide(a.Container,n),i.provide(a.GameObject,n),i.provide(a.RenderTextureRenderList,void 0),{object:n}}});function z(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const Z=u(V,[["render",z]]),K=i.defineComponent({emits:[...y],props:{...g,...f("width","height","fillColor","fillAlpha","lineWidth","strokeColor","strokeAlpha")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Rectangle(r,e.x||0,e.y||0,e.width,e.height);return m(n,e,t),i.provide(a.GameObject,n),{object:n}}});function q(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const J=u(K,[["render",q]]),Q=i.defineComponent({emits:[...y],props:{...g,...f("width","height","radius","fillColor","fillAlpha","lineWidth","strokeColor","strokeAlpha")},setup(e,t){const r=i.inject(a.Scene);class n extends Phaser.GameObjects.Graphics{constructor(s,h,p,b,$,S){super(s,h,p,b,$),this._originX=0,this._originY=0,this._width=b||0,this._height=$||0,this._radius=S||0,this._fillColor=null,this._fillAlpha=1,this._lineWidth=0,this._strokeColor=null,this._strokeAlpha=1,this.setRenderFlag(!0)}preUpdate(...s){this.renderFlag&&this.render()}setRenderFlag(s){this.renderFlag=s}render(){this.setRenderFlag(!1);const s=this.originX*-this.width,h=this.originY*-this.height,p=typeof this.radius=="number"?Math.min(this.radius,this.width/2,this.height/2):this.radius;this.clear(),this.fillColor!==null&&(this.fillStyle(this.fillColor,this.fillAlpha),this.fillRoundedRect(s,h,this.width,this.height,p)),this.lineWidth&&this.strokeColor!==null&&(this.lineStyle(this.lineWidth,this.strokeColor,this.strokeAlpha),this.strokeRoundedRect(s,h,this.width,this.height,p))}get originX(){return this._originX}set originX(s){this._originX=s,this.displayOriginX=this.width*s,this.setRenderFlag(!0)}get originY(){return this._originY}set originY(s){this._originY=s,this.displayOriginY=this.height*s,this.setRenderFlag(!0)}setOrigin(s,h){return this.originX=s,this.originY=h===void 0?s:h,this}get radius(){return this._radius}set radius(s){this._radius=s,this.setRenderFlag(!0)}setRadius(s){return this.radius=s,this}get width(){return this._width}set width(s){this._width=s,this.fixSize(),this.setRenderFlag(!0)}get height(){return this._height}set height(s){this._height=s,this.fixSize(),this.setRenderFlag(!0)}setSize(s,h){return s!==void 0&&(this.width=s),h!==void 0&&(this.height=h),this}fixSize(){this.input&&this.input.hitArea.setSize(this.width,this.height),this.body&&this.body.setSize(this.width,this.height)}get displayWidth(){return Math.abs(this.scaleX*this.width)}set displayWidth(s){this.scaleX=s/this.width}get displayHeight(){return Math.abs(this.scaleY*this.height)}set displayHeight(s){this.scaleY=s/this.height}get fillColor(){return this._fillColor}set fillColor(s){this._fillColor=s,this.setRenderFlag(!0)}get fillAlpha(){return this._fillAlpha}set fillAlpha(s){this._fillAlpha=s,this.setRenderFlag(!0)}setFillStyle(s,h){return s!==void 0&&(this.fillColor=s),h!==void 0&&(this.fillAlpha=h),this}get lineWidth(){return this._lineWidth}set lineWidth(s){this._lineWidth=s,this.setRenderFlag(!0)}get strokeColor(){return this._strokeColor}set strokeColor(s){this._strokeColor=s,this.setRenderFlag(!0)}get strokeAlpha(){return this._strokeAlpha}set strokeAlpha(s){this._strokeAlpha=s,this.setRenderFlag(!0)}setStrokeStyle(s,h,p){return s!==void 0&&(this.lineWidth=s),h!==void 0&&(this.strokeColor=h),p!==void 0&&(this.strokeAlpha=p),this}}const o=new n(r,e.x||0,e.y||0,e.width,e.height,e.radius);return m(o,e,t),i.provide(a.GameObject,o),{object:o}}});function ee(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const te=u(Q,[["render",ee]]),ne=i.defineComponent({emits:[...y],props:{...g,...f("x1","y1","x2","y2","x3","y3","fillColor","fillAlpha","lineWidth","strokeColor","strokeAlpha")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Triangle(r,e.x||0,e.y||0,e.x1,e.y1,e.x2,e.y2,e.x3,e.y3);return m(n,e,t),i.provide(a.GameObject,n),{object:n}}});function ie(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const re=u(ne,[["render",ie]]),se=i.defineComponent({emits:[...y],props:{...g,...f("radius","fillColor","fillAlpha","lineWidth","strokeColor","strokeAlpha")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Arc(r,e.x||0,e.y||0,e.radius);return m(n,e,t),i.provide(a.GameObject,n),{object:n}}});function oe(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const ae=u(se,[["render",oe]]),le=i.defineComponent({emits:[...y],props:{...g,...f("points","fillColor","fillAlpha","lineWidth","strokeColor","strokeAlpha","points")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Polygon(r,e.x||0,e.y||0,e.points);return m(n,e,t),i.provide(a.GameObject,n),{object:n}}});function ce(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const de=u(le,[["render",ce]]),he=i.defineComponent({emits:[...y],props:{...g,...f("x1","y1","x2","y2","lineWidth","strokeColor","strokeAlpha")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Line(r,e.x||0,e.y||0,e.x1,e.y1,e.x2,e.y2);return m(n,e,t),i.provide(a.GameObject,n),{object:n}}});function pe(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const ue=u(he,[["render",pe]]),me=i.defineComponent({emits:[...y],props:{...g,...f("texture","frame","tint","flipX","flipY")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Image(r,e.x||0,e.y||0,e.texture);return m(n,e,t),i.provide(a.GameObject,n),{object:n}}});function fe(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const ge=u(me,[["render",fe]]),ye=i.defineComponent({emits:[...y],props:{...g,...f("width","height","leftWidth","rightWidth","topHeight","bottomHeight","texture","frame","tint")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.NineSlice(r,e.x||0,e.y||0,e.texture,e.frame,e.width,e.height,e.leftWidth,e.rightWidth,e.topHeight,e.bottomHeight);return m(n,e,t),i.provide(a.GameObject,n),{object:n}}});function _e(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const $e=u(ye,[["render",_e]]),R=[{attr:"onAnimationstart",emit:"animationstart"},{attr:"onAnimationupdate",emit:"animationupdate"},{attr:"onAnimationrepeat",emit:"animationrepeat"},{attr:"onAnimationcomplete",emit:"animationcomplete"},{attr:"onAnimationstop",emit:"animationstop"},{attr:"onAnimationrestart",emit:"animationrestart"}],be=i.defineComponent({emits:[...y,...R.map(e=>e.emit)],props:{...g,...f("texture","frame","tint","flipX","flipY"),play:{type:[String,Object]}},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Sprite(r,e.x||0,e.y||0,e.texture),l=i.getCurrentInstance().vnode.props||[];return R.filter(s=>s.attr in l).forEach(s=>{n.on(s.emit,(...h)=>{t.emit(s.emit,...h)})}),m(n,e,t),i.provide(a.GameObject,n),{object:n}}});function Se(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const we=u(be,[["render",Se]]),Oe=i.defineComponent({emits:[...y],props:{...g,...f("text","style","lineSpacing","padding")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Text(r,e.x||0,e.y||0,e.text);return m(n,e,t),{object:n}}});function Ce(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const Pe=u(Oe,[["render",Ce]]),xe=i.defineComponent({emits:["create"],props:{...g,...f("width","height","collision","collisionByProperty"),tilemap:{type:Object},layerIndex:{type:Number},tileset:{type:[Array,String]},cullPadding:{type:Number},cullPaddingX:{type:Number},cullPaddingY:{type:Number}},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.Tilemaps.TilemapLayer(r,e.tilemap,e.layerIndex,e.tileset,e.x||0,e.y||0);return m(n,e,t),{object:n}}});function Ne(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const Ye=u(xe,[["render",Ne]]),Xe=i.defineComponent({emits:[...y],props:{...Object.fromEntries(Object.entries(g).filter(([e])=>!["alpha","blendMode","pipeline"].includes(e))),...f("width","height")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.Zone(r,e.x||0,e.y||0,e.width,e.height);return m(n,e,t),{object:n}}});function Ae(e,t,r,n,o,l){return null}const Re=u(Xe,[["render",Ae]]),Ge=i.defineComponent({emits:["create"],props:{...f("tween","tweens","timeline","visible","x","y","radius","color","intensity")},setup(e,t){const r=new Phaser.GameObjects.Light(e.x||0,e.y||0);return m(r,e,t),{object:r}}});function We(e,t,r,n,o,l){return null}const ke=u(Ge,[["render",We]]),Te=i.defineComponent({emits:["create"],props:{...f("width","height","offsetX","offsetY","enable")},setup(e,t){const r=i.inject(a.Scene);if(!r.physics)throw Error("Physics is not available. Add physics setting to your game config. e.g. `physics: { default: 'arcade' }`");const n=i.inject(a.GameObject),o=r.physics.add.existing(n,Phaser.Physics.Arcade.STATIC_BODY).body;m(o,e,t)}});function Be(e,t,r,n,o,l){return null}const Fe=u(Te,[["render",Be]]),Ee=i.defineComponent({emits:["create"],props:{...f("width","height","offsetX","offsetY","enable","immovable","moves","bounceX","bounceY","drag","dragX","dragY","gravityX","gravityY","frictionX","frictionY","velocityX","velocityY","maxVelocityX","maxVelocityY","accelerationX","accelerationY","collideWorldBounds")},setup(e,t){const r=i.inject(a.Scene);if(!r.physics)throw Error("Physics is not available. Add physics setting to your game config. e.g. `physics: { default: 'arcade' }`");const n=i.inject(a.GameObject),o=r.physics.add.existing(n,Phaser.Physics.Arcade.DYNAMIC_BODY).body;m(o,e,t)}});function Ie(e,t,r,n,o,l){return null}const ve=u(Ee,[["render",Ie]]),Le=i.defineComponent({emits:[...y],props:{...g,...f("width","height")},setup(e,t){const r=i.inject(a.Scene),n=new Phaser.GameObjects.RenderTexture(r,e.x||0,e.y||0,e.width,e.height);m(n,e,t);const o=[];i.provide(a.RenderTextureRenderList,o),i.provide(a.GameObject,n);const l=()=>{n.beginDraw(),o.forEach(s=>n.batchDraw(s)),n.endDraw()};return i.onMounted(()=>{l()}),i.onUpdated(()=>{n.clear(),l()}),{object:n}}});function De(e,t,r,n,o,l){return i.renderSlot(e.$slots,"default")}const Ue=u(Le,[["render",De]]),Me=()=>{console.error("Phavuer::createPhavuerApp() has been removed. Please use `<Game>` component instead. See: https://github.com/laineus/phavuer")},je=e=>e.replace(/-./g,t=>t[1].toUpperCase()),m=(e,t,r)=>{const n=i.getCurrentInstance(),o="bounce"in e,l=e.constructor===Phaser.GameObjects.Light,s=i.inject(a.Scene),h=i.inject(a.RenderTextureRenderList);if(l)s.lights.active||s.lights.enable(),s.lights.lights.push(e);else if(!o)if(h)h.push(e),i.onBeforeUnmount(()=>{const d=h.findIndex(_=>_===e);h.splice(d,1)});else{s.add.existing(e);const d=i.inject(a.Container);if(d){const _=d.list.findIndex(O=>O.depth>(t.depth??0));_===-1?d.add(e):d.addAt(e,_)}}const p=Object.fromEntries(Object.entries(n.vnode.props??{}).map(([d,_])=>[je(d),_])),b=Object.keys(p).filter(d=>d.startsWith("onUpdate:")).map(d=>d.split(":")[1]).filter(d=>X.includes(d)),S=Object.entries(p).filter(([d])=>A[d]).map(([d,_])=>{const O=A[d](e,b.includes(d)?r.emit:void 0);return O(_),i.watch(()=>t[d],O,{deep:k.includes(d)})}).filter(Boolean);p.onCreate&&r.emit("create",e);const w=C.filter(d=>d.attr in p);return w.length&&(e.input||e.setInteractive(),w.some(d=>d.drag)&&s.input.setDraggable(e),w.forEach(d=>{e.on(d.emit,(..._)=>{"eventIndex"in d&&(_[0].stopPropagation=_[d.eventIndex].stopPropagation),r.emit(d.emit,..._)})})),i.onBeforeUnmount(()=>{e.tween&&e.tween.stop(),S.forEach(d=>d())}),l?i.onBeforeUnmount(()=>s.lights.removeLight(e)):i.onBeforeUnmount(()=>e.destroy()),e},a={Game:"phavuer_game",Scene:"phavuer_scene",GameObject:"phavuer_gameObject",Container:"phavuer_container",RenderTextureRenderList:"phavuer_renderTextureRenderList",PreUpdateEvents:"phavuer_preUpdateEvents",PostUpdateEvents:"phavuer_postUpdateEvents"},G=e=>()=>{const t=i.inject(e);if(!t)throw new Error(`${e} is not provided`);return t},He=G(a.Game),Ve=G(a.Scene),x=(e,t)=>i.customRef((r,n)=>({get(){return r(),e},set(o){e&&o||(e=o?o[t]:null,n())}})),ze=e=>x(e,"object"),Ze=e=>x(e,"scene"),W=e=>t=>{const r=i.inject(e);r.push(t),i.onBeforeUnmount(()=>{const n=r.findIndex(o=>o===t);r.splice(n,1)})},Ke=W(a.PreUpdateEvents),qe=W(a.PostUpdateEvents);c.Body=ve,c.Circle=ae,c.Container=Z,c.Game=v,c.Image=ge,c.InjectionKeys=a,c.Light=ke,c.Line=ue,c.NineSlice=$e,c.Polygon=de,c.Rectangle=J,c.RenderTexture=Ue,c.RoundRectangle=te,c.Scene=U,c.Sprite=we,c.StaticBody=Fe,c.Text=Pe,c.TilemapLayer=Ye,c.Triangle=re,c.Zone=Re,c.createPhavuerApp=Me,c.initGameObject=m,c.onPostUpdate=qe,c.onPreUpdate=Ke,c.refObj=ze,c.refScene=Ze,c.refTo=x,c.useGame=He,c.useScene=Ve,Object.defineProperty(c,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=phavuer.umd.js.map
